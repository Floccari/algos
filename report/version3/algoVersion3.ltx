\documentclass[a4paper,11pt]{article}
\usepackage{geometry}
\geometry{a4paper, total={170mm,257mm}, left=20mm, top=20mm}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algorithmic}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\begin{document}
\begin{algorithm}
\renewcommand{\thealgorithm}{}
\floatname{algorithm}{}
\caption{diagnosis(netBs,split)}
\begin{algorithmic}[1]
\STATE \COMMENT {considerando netBs come una rete comportamentale}
\STATE \COMMENT {Definiamo gli stati "One To One" come quelli con una sola transizione entrante ed uscente e consideriamo tutti gli altri come "Many To Many", due transizioni vengono definite parallele se hanno in comune lo stato di partenza e di arrivo}
\STATE $automaton \leftarrow sutomatons[netBs]$
\STATE $replaceInitialState(netBs)$
\STATE $replaceEndStates(netBS)$
\STATE $tran \leftarrow transitions[automaton]$
\STATE $states \leftarrow states[automaton]$
\WHILE {$(split=FALSE$ \AND $next[tran] \neq NIL)$ \OR $(split=FALSE$ \AND $(next[next[states]] \neq NIL$ \OR $multipleTr(automaton=TRUE)))$ }
\STATE $replaceOneToOneStates(netBs)$
\STATE $unifyParallelTransitions(netBs)$
\STATE $replaceManyToManyStates(netBs)$
\IF    {$tran = NIL$}
\STATE $error()$
\ENDIF 
\ENDWHILE
\RETURN $tran$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\renewcommand{\thealgorithm}{}
\floatname{algorithm}{}
\caption{connectTwoStates(network,source,destination,relevanceLabel)}
\begin{algorithmic}[1]
\STATE $transition \leftarrow initialiseTranstition()$
\STATE $src[transition] \leftarrow source$
\STATE $dest[tranEnd] \leftarrow destination$
\STATE $rel[transition] \leftarrow relevanceLabel$
\STATE $addTransition(transition,network)$
\RETURN $transition$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\renewcommand{\thealgorithm}{}
\floatname{algorithm}{}
\caption{replaceInitialState(network)}
\begin{algorithmic}[1]
\STATE $automaton \leftarrow automatons[network]$
\STATE $initState \leftarrow initialiseState()$
\STATE $addState(init,network)$
\STATE $stateToStart \leftarrow initial[automaton]$
\STATE $connectTwoStates(network,stateToStart,initState,NIL)$
\STATE $initial[automaton] \leftarrow initState$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\renewcommand{\thealgorithm}{}
\floatname{algorithm}{}
\caption{replaceEndStates(network,split)}
\begin{algorithmic}[1]
\STATE $automaton \leftarrow automatons[network]$
\STATE $endState \leftarrow initialiseState()$
\STATE $totalState \leftarrow states[automaton]$
\WHILE {$totalState \neq NIL$}
\IF    {$final[totalState] = TRUE$}
\STATE $connectTwoStates(network,totalState,endState,NIL)$
\STATE $final[totalState] \leftarrow FALSE$
\ENDIF 
\STATE $totalState \leftarrow next[totalState]$
\ENDWHILE
\STATE $final[endState] \leftarrow TRUE$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\renewcommand{\thealgorithm}{}
\floatname{algorithm}{}
\caption{createNewRelevanceLabel(newId)}
\begin{algorithmic}[1]
\STATE $newLabel \leftarrow initialiseLabel()$
\STATE $id[newLabel] \leftarrow newId$
\STATE $labelType[newLabel] \leftarrow RELEVANCE$
\RETURN $newLabel$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\renewcommand{\thealgorithm}{}
\floatname{algorithm}{}
\caption{replaceOneToOneStates(network)}
\begin{algorithmic}[1]
\STATE $automaton \leftarrow automatons[network]$
\STATE $totalState \leftarrow states[network]$
\WHILE {$totalState \neq NIL$}
\STATE $transitionIn \leftarrow trIn[totalState]$
\STATE $transitionOut \leftarrow trOut[totalState]$
\IF {$transitionIn \neq NIL $ \AND $next[transitionIn] = NIL$ \AND $transitionOut \neq NIL$ \AND
$next[transitionOut] = NIL$}
\STATE $labelIn \leftarrow rel[transitionIn]$
\STATE $labelOut \leftarrow rel[transitionOut]$
\STATE $newId \leftarrow oneToOneRelation(id[LabelIn],id[LabelOut])$
\STATE $newLabel \leftarrow createNewRelevanceLabel(newId)$
\STATE $tran \leftarrow connectTwoStates(network,transitionIn,transitionOut,newLabel)$
\IF {$split = TRUE$}
\IF {$final[totalState]=TRUE$}
\STATE $tran $
\ENDIF
\ENDIF
\STATE $removeTheState(automaton,totalState)$
\ENDIF
\STATE $totalState \leftarrow next[totalState]$
\ENDWHILE
\end{algorithmic}
\end{algorithm}



\begin{algorithm}
\renewcommand{\thealgorithm}{}
\floatname{algorithm}{}
\caption{unifyParallelTransitions(network)}
\begin{algorithmic}[1]
\STATE \COMMENT {lookup contiene la chiave usata per mappare la transizione all'interno dell'hashmap, una stringa contenente l'identificativo dello stato sorgente e lo stato di destinazione}
\STATE $automaton \leftarrow automatons[network]$
\STATE $transitionHashMap \leftarrow createHashmap()$
\STATE $ids \leftarrow createList()$
\STATE $tran \leftarrow transitions[automaton]$
\WHILE {$tran \neq NIL$}
\STATE $lookup \leftarrow createLookUpForHashmap(tran)$
\STATE $item \leftarrow hashmapSearch (transitionHashmap,lookup)$
\IF{$item = NIL$}
\STATE $itemForMap \leftarrow createItem(lookup,tran)$
\STATE $hashMapInsert(transitionHashmap,itemForMap)$
\ELSE 
\STATE $parallelTransition \leftarrow value[item]$
\STATE $label1 \leftarrow rel[parallelTransition]$
\STATE $label2 \leftarrow rel[tran]$
\STATE $newId \leftarrow parallelRelation(id[label1],id[label2])$
\STATE $rel[parallelTransition] \leftarrow createNewRelevanceLabel(newId)$
\STATE $removeTransition(automaton,tran)$
\ENDIF
\STATE $tran \leftarrow next[tran]$
\ENDWHILE
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\renewcommand{\thealgorithm}{}
\floatname{algorithm}{}
\caption{replaceManyToManyStates(network)}
\begin{algorithmic}[1]
\STATE \COMMENT {questa funzione riassume le righe 21-31 dello pseudocodice nella consegna}
\STATE $automaton \leftarrow automatons[network]$
\STATE $totalState \leftarrow states[automaton]$
\WHILE{$totalState \neq NIL$}
\IF{$initial[aut] \ne totalState $ \AND $final[automaton] \neq totalState$}
\STATE $autoTransitionRel \leftarrow removeAutoTansition(totalState)$
\STATE $unifyAllTransitionsInState(totalState,autoTransitionRel)$
\ENDIF
\STATE $totalState \leftarrow next[totalState]$
\ENDWHILE
\end{algorithmic}
\end{algorithm}



\begin{algorithm}
\renewcommand{\thealgorithm}{}
\floatname{algorithm}{}
\caption{unifyAllTransitionsInState(state)}
\begin{algorithmic}[1]
\STATE $transitionIn \leftarrow trIn[state]$
\STATE $transitionOut \leftarrow trOut[state]$
\WHILE {$transitionIn \neq NIL$}
\WHILE {$transitionOut \neq NIL$}
\STATE $labelIn \leftarrow rel[transitionIn]$
\STATE $labelOut \leftarrow rel[transitionOut]$
\STATE $newId \leftarrow manyToManyRel(id[labelIn],id[labelOut],autoTransitionRel)$
\STATE $newLabel \leftarrow createNewRelevanceLabel(newId)$
\STATE $connectTwoStates(network,src[transitionIn],dest[transitionOut],newLabel)$ 
\STATE $transitionOut \leftarrow next[transitionOut]$
\STATE $removeTheState(automaton,totalState)$
\ENDWHILE
\STATE $transitionIn \leftarrow next[transitionIn]$ 
\ENDWHILE
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\renewcommand{\thealgorithm}{}
\floatname{algorithm}{}
\caption{removeAutoTransition(state)}
\begin{algorithmic}[1]
\STATE $transitionIn \leftarrow trIn[totalState]$
\STATE $autoTransitionRel \leftarrow NIL$
\WHILE {$transitionIn \neq NIL$}
\IF{$src[transitionIn] = dest[transitionIn]$ \AND $rel[transitionIn] = NIL$}
\STATE $labelRel \leftarrow rel[transitionIn]$
\STATE $autoTransitionRel \leftarrow id[labelRel]$
\STATE $removeTransition(automaton,transitionIn)$
\RETURN $autoTransitionRel$
\ENDIF
\STATE $transitionIn \leftarrow next[transitionIn]$
\ENDWHILE
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\renewcommand{\thealgorithm}{}
\floatname{algorithm}{}
\caption{removeTheState(automaton,state)}
\begin{algorithmic}[1]
\STATE \COMMENT{Prima di eliminare lo stato dalla lista dell'automa bisogna liberarsi di tutte le transizioni in entrate e in uscita dallo stato}
\STATE automaton	
\STATE $transitionIn \leftarrow trIn[state]$
\WHILE {$transitionIn \neq NIL $}
\STATE $tran \leftarrow transitionIn$
\STATE $removeTransition(tran)$
\STATE $transitionIn \leftarrow next[transitionIn] $
\ENDWHILE
\STATE $transitionOut \leftarrow trOut[state]$
\WHILE {$transitionOut \neq NIL $}
\STATE $tran \leftarrow transitionOut$
\STATE $removeTransition(tran)$
\STATE $transitionOut \leftarrow next[transitionOut] $
\ENDWHILE
\STATE $sttrHashMap \leftarrow sttrHashMap[automaton]$
\STATE $item \leftarrow statePuntactorSearch(state,sttrHashMap)$
\STATE $listRemove(states[automaton],item)$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\renewcommand{\thealgorithm}{}
\floatname{algorithm}{}
\caption{removeTransition(transition,state)}
\begin{algorithmic}[1]
\STATE \COMMENT{Per eliminare la transizione bisogna rimuoverla dalla lista dello stato in entrata e in uscita e dall'automa dove risiede}
\STATE $sttrHashMap \leftarrow sttrHashMap[automaton]$
\STATE $item \leftarrow transitionOutPuntactorSearch(transition,sttrHashMap)$
\STATE $srcState \leftarrow src[transition]$
\STATE $listRemove(trOut[scrState],item)$
\STATE $item \leftarrow transitionInPuntactorSearch(transition,sttrHashMap)$
\STATE $destState \leftarrow dest[transition]$
\STATE $listRemove(trIn[destState],item)$
\STATE $item \leftarrow transitionPuntactorSearch(transition,sttrHashMap)$
\STATE $listRemove(transitions[automaton],item)$
\end{algorithmic}
\end{algorithm}

\end{document}
