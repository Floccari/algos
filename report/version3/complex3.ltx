\documentclass[a4paper,11pt]{article}
\usepackage{geometry}
\geometry{a4paper, total={170mm,257mm}, left=20mm, top=20mm}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algorithmic}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\begin{document}

\section{Analisi dello pseudocodice nella versione 3}
La versione 3 si occupa dell'implementazione degli algoritmi descritti nella consegna del progetto quindi di \emph{EspressioneRegolare} ed \emph{EspressioniRegolari}: per comodità ed evitare ridondanza entrambi i procedimenti sono stati implementati nello stesso pseudocodice discriminando le varie righe con l'uso della variabile \emph{split}. \newline

\subsection{Ottimizzazioni e gestioni delle rimozioni}
I punti critici da gestire per questa versione saranno le varie ricerche da effettuare per controllare gli stati e le transizioni della rete comportamentale: per attenuare il carico computazionale nell'algoritmo
\emph{unifyParallelTransition} è stata implementata un'hashMap per il controllo delle transizioni chiamata \emph{trHashMap} (riga 3).
\newline
\newline
Per questa versione la gestione delle rimozioni di stati e transizioni ottimale diventa fondamentale infatti, a causa della strutture dati implementate in questo progetto, la rimozione di un nodo o transizione della rete è formata da una serie continua di ricerche in varie liste, visto che dovranno essere chiamate un \emph{O(s)} volte il carico computazionale di queste rimozioni rischia di diventare oneroso.
\newline
\newline
Per facilitare la ricerca è stata implementata una HashMap in \emph{automaton} chiamata \emph{sttrHashMap}: questa contiene tutti i puntatori di stati e transizioni alle varie liste ad esempio, se una transizione $t$ sarà uscente in uno stato $s_o_u_t$ ed entrante in uno stato $s_i_n$, $t$ si troverà puntato sia nella lista $out[s_o_u_t]$ che nella lista $in[s_i_n]$ oltre che nella lista dell'automa $transitions[automa]$, quindi troveremo tre item in \emph{sttrHashMap} che punteranno ai seguenti puntatori, stessa cosa vale per gli stati. Al posto di cercare in singole liste ogni singolo puntatore facente rifermiento al determinato oggetto che stiamo rimuovendo basterà cercare in \emph{sttrHashMap} l'item desiderato e rimuovere dalla lista. La gestione delle singole ricerche sarà affidato da un metodo specifico che nello pseudocodice  è definito da varie funzioni (\emph{statePointerSearch,transitionInPointerSearch,transitionPointerSearch}) specificate per aumentare la leggibilità
\newline
\newline
Il miglioramento è di un ordine di grandezza infatti $removeTheState=O(s)$ mentre $removeTransition=O(1)$ contro rispettivamente i $O(s^2+ts)$ e $O(t+s)$ precedenti: valgono le stesse ipotesi fatte per $ctrHashMap$ visto che sia $trHashMap$ e sia $sttrHashMap$ sono a concatenazione e usano la stessa funzione di hash quindi effettuano una ricerca in un tempo medio $O(1)$

\subsection{Analisi delle complessità in \emph{diagnosis}}
\subsubsection{Calcolo della complesstià computazionale}
Il maggior carico che troviamo in questo algoritmo è rappresentato dal ciclo while (righe 7-13) e dagli algoritmi che contiene (\emph{replaceOneToOneState,unifyParallelTransitions,replaceManyToManyStates}. \newline
Consideriamo prima il ciclo while che continuerà a ripetersi finchè non si troverà una sola transizione nella rete contente l'espressione regolare calcolata: sia $s_i$ e $t_i$ rispettivamente il numero di stati e transizioni della rete comportamentale in input nell'algoritmo nell'iesima iterazione del ciclo. Per semplificare consideriamo $s_i$ e $t_i$ costanti per tutta l'iterazione e che varino solo alla fine di quest'ultima.  
\newline
nella prima iterazione:
\[s_1=s+2,t_1=t+f \] 
dove $s$, $t$ ed $f$ sono rispettivamente il numero di nodi, transizioni e stati finali nella rete, grazie agli algoritmi \emph{replaceInitialState} e \emph{replaceEndState} (righe 4-5) aggiungiamo uno stato iniziale e finale (\emph{initState} e \emph{endState} ) oltre che aggiungere una transizione da ogni stato finale ad \emph{endState}.
Nell'iterazione successiva $s_2<s_1$ e $t_2<t_1$ per costruzione stessa cosa per le iterazioni successive:

\[\forall i=1,2...,m : s_i < s_i_-_1, t_i < t_i_-_1 \]   

Possiamo quindi omettere la complessità delle iterazioni successive alla prima perchè poco significanti per il calcolo complessivo.
\newline
\newline
\emph{replaceOneToOneStates} pesa $O(s_1^2)$ per costruzione, \emph{parallelTransitions} controlla tutte le transizioni della rete quindi $t_1=O(s_1^2)$ nel caso peggiore di rete completa ed infine \emph{replaceManyToManyStates} a causa del'algoritmo \emph{unifyAllTransitionState} (riga 7) ($O(s_1^3)$) arriva a pesare $O(s_1^4)$ sovrastando gli altri due. Possiamo quindi indicare la complessità computazionale di \emph{diagnosis} come:

\[O(s_1^4) \simeq O(s^4) = O((a^3n^a^+^1l^ko)^4) \]

\subsubsection{Considerazioni spaziali sull'implementazione di \emph{sttrHashMap}}

Per quanto \emph{sttrHashMap} ottimizzi al meglio i tempi di rimozione la dimensione dell'hashMap risulta molto grande:\newline
\emph{sttrHashMap} contiene tutti i puntatori inerenti alle seguenti liste:
\begin{itemize}
\item \emph{transitions[automa]} di cardinalità \emph{t} (considerando un solo automa come nelle reti comportamentali)
\item le liste \emph{trIn[stato]} che sommate portano ad una cardinalità totale \emph{t}
\item le liste \emph{trOut[stato]} che sommate portano anche loro ad una cardinalità \emph{t}
\item \emph{states[automa]} di cardinalità \emph{s} (considerando l'automa della rete comportamentale) 
\end{itemize}
Quindi l'HashMap conterrà esattamente $d=3t+s$ elementi e quindi:

\[d=O(3s^2)\]

per quanto questo valore, di una struttura dati non necessaria per l'implementazione del programma, possa pesare sulla memoria occupata preferiamo concentrarci sulla velocità di esecuzione considerando le specifiche base di un calcolatore medio capace ancora almeno, per gli esempi considerati, di contenere questo problema.  






 	

\end{document}
